import { IAudioNormalizationService } from '../application/ports/IAudioNormalizationService';
import { WebAudioAdapter } from './web-audio/WebAudioAdapter';
import { AudioProcessor } from '../domain/entities/AudioProcessor';
import { AudioConfig } from '../domain/value-objects/AudioConfig';
import { GainValue } from '../../shared/domain/value-objects/GainValue';
import { ILogger } from '../../shared/infrastructure/logger/ILogger';
import { DomainEventPublisher } from '../../shared/domain/events/DomainEventPublisher';
import { NormalizerActivatedEvent } from '../../shared/domain/events/NormalizerActivatedEvent';
import { ConfigurationChangedEvent } from '../../shared/domain/events/ConfigurationChangedEvent';
import { AudioProcessingConstants } from '../domain/constants/AudioProcessingConstants';

export class AudioNormalizationService implements IAudioNormalizationService {
  private processor: AudioProcessor;
  private adapter: WebAudioAdapter;
  private isActive: boolean = false;
  private animationFrameId: number | null = null;
  private currentVideo: HTMLVideoElement | null = null;
  private seekingListener: (() => void) | null = null;
  private videoRemovalObserver: MutationObserver | null = null;
  private lastNormalizationTime: number = 0;

  constructor(
    initialConfig: AudioConfig,
    private readonly logger: ILogger,
    private readonly eventPublisher: DomainEventPublisher
  ) {
    this.processor = new AudioProcessor(initialConfig);
    this.adapter = new WebAudioAdapter(logger);
  }

  /**
   * Attaches audio normalization to a video element.
   * @param video Target video element
   */
  public attachToVideo(video: HTMLVideoElement): void {
    if (this.currentVideo === video && this.adapter.isInitialized()) {
      this.logger.info('Already attached to this video');
      this.logger.debug('attachToVideo - Already attached, skipping');
      return;
    }

    this.logger.info('Attaching to video element');
    this.logger.debug('attachToVideo - NEW ATTACHMENT:', {
      videoSrc: video.src || video.currentSrc,
      videoReadyState: video.readyState,
      videoConnected: video.isConnected,
      previousVideoExists: this.currentVideo !== null,
      previousVideoConnected: this.currentVideo?.isConnected ?? false,
      sameVideoElement: this.currentVideo === video,
      adapterWasInitialized: this.adapter.isInitialized()
    });

    if (this.currentVideo !== video) {
      this.logger.debug('attachToVideo - Soft detaching from previous video (preserving AudioContext)');
      this.detachFromVideo();
    }

    this.currentVideo = video;

    try {
      this.adapter.attachToVideo(video);
      this.logger.debug('attachToVideo - After attachment, adapter initialized:', this.adapter.isInitialized());
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const isSourceNodeConflict = errorMessage.includes('already has') ||
                                   errorMessage.includes('MediaElementAudioSourceNode') ||
                                   errorMessage.includes('already being used');

      if (isSourceNodeConflict) {
        this.logger.warn('MediaElementSource conflict detected - cleaning up and retrying once');
        this.logger.warn('MediaElementSource conflict detected, attempting recovery with cleanup and retry');

        try {
          this.adapter.cleanup();
          this.logger.debug('Retrying attachment after cleanup...');
          this.adapter.attachToVideo(video);
          this.logger.debug('RETRY SUCCESSFUL - adapter initialized:', this.adapter.isInitialized());
          this.logger.info('Successfully attached after MediaElementSource conflict recovery');
        } catch (retryError) {
          this.logger.error('RETRY FAILED after cleanup:', retryError);
          this.logger.error('Failed to attach even after cleanup and retry', retryError);
          this.currentVideo = null;
          throw retryError;
        }
      } else {
        this.logger.error('FAILED to attach adapter to video:', error);
        this.logger.error('Failed to attach adapter to video', error);
        this.currentVideo = null;
        throw error;
      }
    }

    if (this.isActive) {
      this.logger.debug('Normalizer is ACTIVE - connecting in ACTIVE mode (full processing)');
      this.adapter.setActive(true);
    } else {
      this.logger.debug('Normalizer is INACTIVE - connecting in BYPASS mode (direct audio)');
      this.adapter.setActive(false);
    }

    this.adapter.resume();

    this.seekingListener = this.handleSeeking.bind(this);
    video.addEventListener('seeking', this.seekingListener);

    this.videoRemovalObserver = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        for (const node of mutation.removedNodes) {
          if (node === video || (node instanceof Element && node.contains(video))) {
            this.logger.warn('VIDEO REMOVED FROM DOM!', {
              videoSrc: video.src || video.currentSrc,
              wasActive: this.isActive
            });
            this.logger.warn('Video element removed from DOM');
            if (this.videoRemovalObserver) {
              this.videoRemovalObserver.disconnect();
              this.videoRemovalObserver = null;
            }
            break;
          }
        }
      }
    });

    if (video.parentElement) {
      this.videoRemovalObserver.observe(video.parentElement, { childList: true });
    }

    if (this.isActive) {
      this.logger.debug('Starting normalization loop (normalizer is active)');
      this.normalize();
    }
  }

  /**
   * Activates audio normalization.
   */
  public activate(): void {
    if (this.isActive) {
      this.logger.info('Normalizer already active');
      return;
    }

    this.isActive = true;

    if (this.adapter.isInitialized()) {
      this.logger.debug('activate() - Switching from BYPASS to ACTIVE mode');
      this.adapter.setActive(true);
      this.adapter.resume();

      if (this.animationFrameId === null) {
        this.normalize();
      }
    }

    this.eventPublisher.publish(new NormalizerActivatedEvent(true));
    this.logger.info('Normalizer activated');
  }

  /**
   * Deactivates audio normalization.
   */
  public deactivate(): void {
    if (!this.isActive) {
      this.logger.info('Normalizer already inactive');
      return;
    }

    this.isActive = false;

    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }

    if (this.adapter.isInitialized()) {
      this.logger.debug('deactivate() - Switching from ACTIVE to BYPASS mode (audio preserved)');
      this.adapter.setActive(false);
    }

    this.eventPublisher.publish(new NormalizerActivatedEvent(false));
    this.logger.info('Normalizer deactivated');
  }

  /**
   * Updates audio configuration.
   * @param config New audio configuration
   */
  public updateConfig(config: AudioConfig): void {
    this.processor.updateConfig(config);

    this.eventPublisher.publish(
      new ConfigurationChangedEvent({
        targetLevel: config.targetLevel.getValue(),
        maxGain: config.maxGain.getValue(),
        minGain: config.minGain.getValue(),
      })
    );

    this.logger.info('Audio configuration updated');
  }

  /**
   * Returns current gain value.
   * @returns Current gain or safe default if uninitialized
   */
  public getCurrentGain(): GainValue {
    if (!this.adapter.isInitialized()) {
      return GainValue.createSafe(1.0);
    }
    return this.adapter.getCurrentGain();
  }

  /**
   * Checks if video is attached and active in DOM.
   * @returns True if video attached, adapter initialized, and element in DOM
   */
  public hasVideoAttached(): boolean {
    const hasVideo = this.currentVideo !== null;
    const isAdapterInit = this.adapter.isInitialized();
    const isVideoInDOM = this.currentVideo?.isConnected ?? false;
    const result = hasVideo && isAdapterInit && isVideoInDOM;

    this.logger.debug('hasVideoAttached() check:', {
      currentVideo: this.currentVideo ? 'EXISTS' : 'NULL',
      videoInDOM: isVideoInDOM,
      adapterInitialized: isAdapterInit,
      result: result
    });

    if (hasVideo && !isVideoInDOM) {
      this.logger.warn('Video element detached from DOM (will be handled by caller)');
      this.logger.warn('Video element no longer in DOM - reporting false to caller');
    }

    return result;
  }

  /**
   * Checks if normalizer is active.
   * @returns True if normalization is enabled
   */
  public isNormalizerActive(): boolean {
    return this.isActive;
  }


  private normalize = (): void => {
    if (!this.isActive) {
      return;
    }

    const now = performance.now();
    const timeSinceLastUpdate = now - this.lastNormalizationTime;

    if (timeSinceLastUpdate >= AudioProcessingConstants.NORMALIZATION_INTERVAL_MS) {
      try {
        const metrics = this.adapter.getMetrics();
        const nextGain = this.processor.calculateNextGain(metrics);
        this.adapter.setGainSmooth(nextGain, AudioProcessingConstants.GAIN_SMOOTHING_NORMAL);
        this.lastNormalizationTime = now;
      } catch (error) {
        this.logger.error('Error in normalization loop', error);
      }
    }

    this.animationFrameId = requestAnimationFrame(this.normalize);
  };

  private handleSeeking(): void {
    if (!this.isActive || !this.adapter.isInitialized()) {
      return;
    }

    const currentGain = this.adapter.getCurrentGain();
    const resetGain = this.processor.calculateResetGain(currentGain);

    this.adapter.setGainSmooth(resetGain, AudioProcessingConstants.GAIN_SMOOTHING_SEEK_RESET);
    this.logger.info(`Video seeking detected, resetting gain to ${resetGain.toString()}`);
  }

  /**
   * Detaches from current video without destroying AudioContext.
   */
  private detachFromVideo(): void {
    this.logger.debug('detachFromVideo() - soft detach (keeping AudioContext alive)');

    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }

    if (this.adapter.isInitialized()) {
      this.adapter.setActive(false);
    }

    if (this.currentVideo && this.seekingListener) {
      this.currentVideo.removeEventListener('seeking', this.seekingListener);
      this.seekingListener = null;
    }

    if (this.videoRemovalObserver) {
      this.videoRemovalObserver.disconnect();
      this.videoRemovalObserver = null;
    }

    this.currentVideo = null;

    this.logger.info('Soft detached from video (AudioContext preserved for re-attachment)');
  }

  /**
   * Destroys all resources including AudioContext.
   */
  public cleanup(): void {
    this.logger.debug('cleanup() called - FULL TEARDOWN', {
      hadVideo: this.currentVideo !== null,
      wasActive: this.isActive,
      stackTrace: new Error().stack
    });

    this.detachFromVideo();
    this.adapter.cleanup();

    this.logger.info('AudioNormalizationService fully cleaned up (AudioContext destroyed)');
  }
}
